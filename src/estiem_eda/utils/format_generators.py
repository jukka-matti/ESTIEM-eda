"""Format Generator System for Multi-Format Chart Generation.

This module provides generators for different visualization formats, enabling
seamless chart display across various Claude interfaces and platforms.
"""

import json
import sys
from abc import ABC, abstractmethod
from typing import Dict, Any, List, Optional
import logging

from .visualization_response import (
    ChartData, FormatContent, ArtifactData, VisualizationFormat
)


class BaseFormatGenerator(ABC):
    """Abstract base class for format generators."""
    
    def __init__(self):
        self.logger = logging.getLogger(self.__class__.__name__)
    
    @abstractmethod
    def generate(self, chart_data: ChartData, **kwargs) -> FormatContent:
        """Generate format-specific content from chart data.
        
        Args:
            chart_data: Structured chart information
            **kwargs: Additional format-specific parameters
            
        Returns:
            Format-specific content with metadata
        """
        pass
    
    def calculate_size_kb(self, content: str) -> float:
        """Calculate content size in KB.
        
        Args:
            content: String content to measure
            
        Returns:
            Size in kilobytes
        """
        if isinstance(content, str):
            return len(content.encode('utf-8')) / 1024
        elif isinstance(content, dict):
            return len(json.dumps(content).encode('utf-8')) / 1024
        else:
            return len(str(content).encode('utf-8')) / 1024


class PlotlyHTMLGenerator(BaseFormatGenerator):
    """Generator for interactive HTML with embedded Plotly charts."""
    
    def generate(self, chart_data: ChartData, **kwargs) -> FormatContent:
        """Generate interactive HTML with embedded Plotly.
        
        Args:
            chart_data: Structured chart information
            **kwargs: Additional parameters (title, theme, etc.)
            
        Returns:
            HTML format content with Plotly visualization
        """
        title = kwargs.get('title', f'{chart_data.chart_type.replace("_", " ").title()} Analysis')
        theme = kwargs.get('theme', 'plotly_white')
        
        # Create the HTML template with embedded Plotly
        html_content = f'''<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="ESTIEM EDA Statistical Analysis Visualization">
    <title>{title}</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <style>
        body {{
            font-family: {chart_data.styling_info.get('font_family', 'Open Sans, sans-serif')};
            margin: 0;
            padding: 20px;
            background-color: #f8f9fa;
            color: #333;
        }}
        .container {{
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 20px;
        }}
        .header {{
            text-align: center;
            margin-bottom: 30px;
            border-bottom: 2px solid {chart_data.styling_info.get('brand_colors', {}).get('primary', '#1f4e79')};
            padding-bottom: 15px;
        }}
        .header h1 {{
            color: {chart_data.styling_info.get('brand_colors', {}).get('primary', '#1f4e79')};
            margin: 0;
            font-size: 2em;
            font-weight: 300;
        }}
        .chart-container {{
            width: 100%;
            height: 600px;
            margin: 20px 0;
        }}
        .footer {{
            text-align: center;
            margin-top: 30px;
            padding-top: 15px;
            border-top: 1px solid #e0e0e0;
            color: #666;
            font-size: 0.9em;
        }}
        .estiem-logo {{
            color: {chart_data.styling_info.get('brand_colors', {}).get('primary', '#1f4e79')};
            font-weight: bold;
        }}
        @media (max-width: 768px) {{
            .container {{
                padding: 15px;
                margin: 10px;
            }}
            .chart-container {{
                height: 400px;
            }}
        }}
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>{title}</h1>
        </div>
        <div id="plotly-chart" class="chart-container"></div>
        <div class="footer">
            Generated by <span class="estiem-logo">ESTIEM EDA Toolkit</span> | 
            Statistical Process Control for Lean Six Sigma Education
        </div>
    </div>

    <script>
        // Chart data and configuration
        const data = {json.dumps(chart_data.data_series, indent=2)};
        const layout = {json.dumps(chart_data.layout_config, indent=2)};
        
        // Enhanced layout with ESTIEM styling
        layout.font = layout.font || {{}};
        layout.font.family = "{chart_data.styling_info.get('font_family', 'Open Sans, sans-serif')}";
        layout.font.color = "#333";
        
        layout.plot_bgcolor = 'white';
        layout.paper_bgcolor = 'white';
        layout.margin = layout.margin || {{l: 60, r: 60, t: 80, b: 60}};
        
        // Responsive configuration
        const config = {{
            responsive: true,
            displayModeBar: true,
            displaylogo: false,
            modeBarButtonsToRemove: ['pan2d', 'lasso2d', 'select2d'],
            toImageButtonOptions: {{
                format: 'png',
                filename: 'estiem_chart',
                height: 600,
                width: 900,
                scale: 2
            }}
        }};
        
        // Create the plot
        Plotly.newPlot('plotly-chart', data, layout, config);
        
        // Handle window resize
        window.addEventListener('resize', function() {{
            Plotly.Plots.resize('plotly-chart');
        }});
    </script>
</body>
</html>'''
        
        size_kb = self.calculate_size_kb(html_content)
        
        return FormatContent(
            content=html_content,
            content_type="text/html",
            size_kb=size_kb,
            features=["interactive", "responsive", "exportable", "embeddable"],
            dependencies=["plotly-2.27.0.min.js"],
            standalone=True
        )


class ArtifactGenerator(BaseFormatGenerator):
    """Generator for Claude Artifact-compatible formats."""
    
    def generate_react(self, chart_data: ChartData, **kwargs) -> FormatContent:
        """Generate React component artifact for Claude Desktop.
        
        Args:
            chart_data: Structured chart information
            **kwargs: Additional React-specific parameters
            
        Returns:
            React artifact format content
        """
        component_name = kwargs.get('component_name', f'{chart_data.chart_type.title().replace("_", "")}Chart')
        
        react_content = f'''import React from 'react';
import Plot from 'react-plotly.js';

const {component_name} = ({{ data, layout, config, title }}) => {{
  // Default data from analysis
  const defaultData = {json.dumps(chart_data.data_series, indent=2)};
  
  // Default layout with ESTIEM styling
  const defaultLayout = {{
    ...{json.dumps(chart_data.layout_config, indent=2)},
    font: {{
      family: '{chart_data.styling_info.get('font_family', 'Open Sans, sans-serif')}',
      color: '#333'
    }},
    plot_bgcolor: 'white',
    paper_bgcolor: 'white',
    margin: {{ l: 60, r: 60, t: 80, b: 60 }},
    title: {{
      text: title || '{chart_data.chart_type.replace("_", " ").title()} Analysis',
      font: {{
        size: 20,
        color: '{chart_data.styling_info.get('brand_colors', {}).get('primary', '#1f4e79')}'
      }}
    }}
  }};
  
  // Default configuration
  const defaultConfig = {{
    responsive: true,
    displayModeBar: true,
    displaylogo: false,
    modeBarButtonsToRemove: ['pan2d', 'lasso2d', 'select2d'],
    toImageButtonOptions: {{
      format: 'png',
      filename: 'estiem_chart',
      height: 600,
      width: 900,
      scale: 2
    }}
  }};
  
  return (
    <div style={{{{
      width: '100%',
      height: '600px',
      fontFamily: '{chart_data.styling_info.get('font_family', 'Open Sans, sans-serif')}',
      backgroundColor: 'white',
      border: '1px solid #e0e0e0',
      borderRadius: '8px',
      padding: '20px',
      boxShadow: '0 2px 10px rgba(0,0,0,0.1)'
    }}}}>
      <Plot
        data={{data || defaultData}}
        layout={{{{...defaultLayout, ...layout}}}}
        config={{{{...defaultConfig, ...config}}}}
        style={{{{ width: '100%', height: '100%' }}}}
        useResizeHandler={{true}}
      />
      <div style={{{{
        textAlign: 'center',
        marginTop: '15px',
        fontSize: '0.9em',
        color: '#666',
        borderTop: '1px solid #e0e0e0',
        paddingTop: '15px'
      }}}}>
        Generated by <span style={{{{
          color: '{chart_data.styling_info.get('brand_colors', {}).get('primary', '#1f4e79')}',
          fontWeight: 'bold'
        }}}}>ESTIEM EDA Toolkit</span>
      </div>
    </div>
  );
}};

export default {component_name};'''
        
        artifact_data = ArtifactData(
            artifact_type="react",
            language="jsx",
            content=react_content,
            dependencies=["react", "react-plotly.js"],
            props_schema={
                "data": "array",
                "layout": "object",
                "config": "object",
                "title": "string"
            }
        )
        
        size_kb = self.calculate_size_kb(react_content)
        
        return FormatContent(
            content=artifact_data,
            content_type="application/jsx",
            size_kb=size_kb,
            features=["interactive", "responsive", "component", "reusable"],
            dependencies=["react", "react-plotly.js"],
            standalone=False
        )
    
    def generate_html(self, chart_data: ChartData, **kwargs) -> FormatContent:
        """Generate standalone HTML artifact.
        
        Args:
            chart_data: Structured chart information
            **kwargs: Additional HTML-specific parameters
            
        Returns:
            HTML artifact format content
        """
        # Use the PlotlyHTMLGenerator for HTML content
        html_generator = PlotlyHTMLGenerator()
        html_content_obj = html_generator.generate(chart_data, **kwargs)
        
        artifact_data = ArtifactData(
            artifact_type="html",
            language="html",
            content=html_content_obj.content,
            dependencies=[],
            props_schema=None
        )
        
        return FormatContent(
            content=artifact_data,
            content_type="text/html",
            size_kb=html_content_obj.size_kb,
            features=["interactive", "standalone", "embeddable"],
            dependencies=[],
            standalone=True
        )
    
    def generate(self, chart_data: ChartData, artifact_type: str = "react", **kwargs) -> FormatContent:
        """Generate artifact format based on type.
        
        Args:
            chart_data: Structured chart information
            artifact_type: Type of artifact (react or html)
            **kwargs: Additional parameters
            
        Returns:
            Artifact format content
        """
        if artifact_type == "react":
            return self.generate_react(chart_data, **kwargs)
        elif artifact_type == "html":
            return self.generate_html(chart_data, **kwargs)
        else:
            raise ValueError(f"Unsupported artifact type: {artifact_type}")


class ConfigGenerator(BaseFormatGenerator):
    """Generator for structured chart configuration data."""
    
    def generate(self, chart_data: ChartData, **kwargs) -> FormatContent:
        """Generate structured Plotly configuration.
        
        Args:
            chart_data: Structured chart information
            **kwargs: Additional configuration parameters
            
        Returns:
            Configuration format content
        """
        config_data = {
            "type": chart_data.chart_type,
            "data": chart_data.data_series,
            "layout": chart_data.layout_config,
            "config": {
                "responsive": chart_data.interactivity.get("responsive", True),
                "displayModeBar": chart_data.interactivity.get("displayModeBar", True),
                "displaylogo": False,
                "modeBarButtonsToRemove": ["pan2d", "lasso2d", "select2d"],
                "toImageButtonOptions": {
                    "format": "png",
                    "filename": "estiem_chart",
                    "height": 600,
                    "width": 900,
                    "scale": 2
                }
            },
            "styling": chart_data.styling_info,
            "metadata": {
                **chart_data.metadata,
                "generator": "ESTIEM EDA Enhanced MCP Server",
                "format_version": "1.0"
            }
        }
        
        size_kb = self.calculate_size_kb(config_data)
        
        return FormatContent(
            content=config_data,
            content_type="application/json",
            size_kb=size_kb,
            features=["structured", "reconstructable", "portable"],
            dependencies=[],
            standalone=True
        )


class TextFallbackGenerator(BaseFormatGenerator):
    """Generator for text-based fallback visualizations."""
    
    def generate(self, chart_data: ChartData, analysis_results: Optional[Dict] = None, **kwargs) -> FormatContent:
        """Generate text-based chart representation.
        
        Args:
            chart_data: Structured chart information
            analysis_results: Optional statistical analysis results
            **kwargs: Additional text generation parameters
            
        Returns:
            Text fallback format content
        """
        chart_type = chart_data.chart_type.replace("_", " ").title()
        
        # Create text representation based on chart type
        if chart_data.chart_type == "control_chart" or chart_data.chart_type == "i_chart":
            text_content = self._generate_control_chart_text(chart_data, analysis_results or {})
        elif chart_data.chart_type == "histogram":
            text_content = self._generate_histogram_text(chart_data, analysis_results or {})
        elif chart_data.chart_type == "boxplot":
            text_content = self._generate_boxplot_text(chart_data, analysis_results or {})
        elif chart_data.chart_type == "pareto":
            text_content = self._generate_pareto_text(chart_data, analysis_results or {})
        elif chart_data.chart_type == "probability_plot":
            text_content = self._generate_probability_plot_text(chart_data, analysis_results or {})
        else:
            text_content = self._generate_generic_text(chart_data, analysis_results or {})
        
        size_kb = self.calculate_size_kb(text_content)
        
        return FormatContent(
            content=text_content,
            content_type="text/plain",
            size_kb=size_kb,
            features=["accessible", "universal", "lightweight"],
            dependencies=[],
            standalone=True
        )
    
    def _generate_control_chart_text(self, chart_data: ChartData, results: Dict) -> str:
        """Generate text representation of control chart."""
        stats = results.get('statistics', {})
        return f"""I-Chart Analysis Results
=======================

Process Statistics:
• Sample Size: {stats.get('sample_size', 'N/A')}
• Mean (X̄): {stats.get('mean', 'N/A'):.3f}
• Sigma Hat (σ̂): {stats.get('sigma_hat', 'N/A'):.3f}

Control Limits:
• Upper Control Limit (UCL): {stats.get('ucl', 'N/A'):.3f}
• Lower Control Limit (LCL): {stats.get('lcl', 'N/A'):.3f}

Process Control:
• Out of Control Points: {stats.get('out_of_control_points', 'N/A')}
• Western Electric Violations: {len(stats.get('western_electric_violations', []))}

Data Points: {results.get('data_points', [])}

Interpretation: {results.get('interpretation', 'No interpretation available')}

Generated by ESTIEM EDA Toolkit - Statistical Process Control"""
    
    def _generate_histogram_text(self, chart_data: ChartData, results: Dict) -> str:
        """Generate text representation of histogram/capability analysis."""
        stats = results.get('statistics', {})
        return f"""Process Capability Analysis
=========================

Sample Statistics:
• Sample Size: {stats.get('sample_size', 'N/A')}
• Mean: {stats.get('mean', 'N/A'):.3f}
• Standard Deviation: {stats.get('std_dev', 'N/A'):.3f}

Capability Indices:
• Cp: {stats.get('cp', 'N/A'):.3f}
• Cpk: {stats.get('cpk', 'N/A'):.3f}
• Six Sigma Level: {stats.get('six_sigma_level', 'N/A'):.2f}

Specification Limits:
• LSL: {stats.get('specification_limits', {}).get('lsl', 'N/A')}
• USL: {stats.get('specification_limits', {}).get('usl', 'N/A')}
• Target: {stats.get('specification_limits', {}).get('target', 'N/A')}

Assessment: {results.get('capability_assessment', {}).get('overall_rating', 'Not assessed')}

Generated by ESTIEM EDA Toolkit - Process Capability Analysis"""
    
    def _generate_boxplot_text(self, chart_data: ChartData, results: Dict) -> str:
        """Generate text representation of boxplot/ANOVA."""
        anova = results.get('anova_results', {})
        return f"""One-Way ANOVA Analysis
====================

ANOVA Results:
• F-statistic: {anova.get('f_statistic', 'N/A'):.3f}
• p-value: {anova.get('p_value', 'N/A'):.4f}
• Degrees of Freedom: {anova.get('degrees_freedom', [])}

Effect Size:
• Eta Squared (η²): {anova.get('effect_size', {}).get('eta_squared', 'N/A'):.3f}
• Omega Squared (ω²): {anova.get('effect_size', {}).get('omega_squared', 'N/A'):.3f}

Group Statistics:
{self._format_group_stats(results.get('group_statistics', {}))}

Interpretation: {results.get('interpretation', 'No interpretation available')}

Generated by ESTIEM EDA Toolkit - ANOVA Analysis"""
    
    def _generate_pareto_text(self, chart_data: ChartData, results: Dict) -> str:
        """Generate text representation of Pareto analysis."""
        vital_few = results.get('vital_few', {})
        categories = results.get('categories', [])
        percentages = results.get('percentages', [])
        
        pareto_table = []
        for i, (cat, pct) in enumerate(zip(categories, percentages)):
            pareto_table.append(f"  {i+1:2d}. {cat:<20} {pct:6.1f}%")
        
        return f"""Pareto Analysis Results
======================

Vital Few Identification:
• Categories contributing to {vital_few.get('threshold_used', 80)}%: {vital_few.get('count', 'N/A')}
• Total contribution: {vital_few.get('contribution_percent', 'N/A'):.1f}%

Category Ranking:
{chr(10).join(pareto_table)}

Statistics:
• Total Count: {results.get('statistics', {}).get('total_count', 'N/A')}
• Concentration Ratio: {results.get('statistics', {}).get('concentration_ratio', 'N/A'):.3f}

Interpretation: {results.get('interpretation', 'No interpretation available')}

Generated by ESTIEM EDA Toolkit - Pareto Analysis"""
    
    def _generate_probability_plot_text(self, chart_data: ChartData, results: Dict) -> str:
        """Generate text representation of probability plot."""
        goodness = results.get('goodness_of_fit', {})
        normality = results.get('normality_test', {})
        
        return f"""Probability Plot Analysis
========================

Distribution: {results.get('distribution', 'Normal').title()}

Goodness of Fit:
• Correlation Coefficient: {goodness.get('correlation_coefficient', 'N/A'):.4f}
• R-squared: {goodness.get('r_squared', 'N/A'):.4f}
• Slope: {goodness.get('slope', 'N/A'):.3f}
• Intercept: {goodness.get('intercept', 'N/A'):.3f}

Normality Test ({normality.get('test', 'Anderson-Darling')}):
• Test Statistic: {normality.get('statistic', 'N/A'):.3f}
• p-value: {normality.get('p_value', 'N/A'):.3f}

Outliers Detected: {results.get('outliers', {}).get('count', 0)}

Interpretation: {results.get('interpretation', 'No interpretation available')}

Generated by ESTIEM EDA Toolkit - Probability Plot Analysis"""
    
    def _generate_generic_text(self, chart_data: ChartData, results: Dict) -> str:
        """Generate generic text representation for unknown chart types."""
        return f"""Statistical Analysis Results
==========================

Chart Type: {chart_data.chart_type.replace('_', ' ').title()}

Analysis Results:
{self._format_dict_as_text(results, indent=2)}

Generated by ESTIEM EDA Toolkit - Statistical Process Control"""
    
    def _format_group_stats(self, group_stats: Dict) -> str:
        """Format group statistics for text display."""
        if not group_stats:
            return "  No group statistics available"
        
        lines = []
        for group_name, stats in group_stats.items():
            mean = stats.get('mean', 'N/A')
            std = stats.get('std', 'N/A')
            n = stats.get('n', 'N/A')
            lines.append(f"  {group_name}: Mean={mean:.3f}, SD={std:.3f}, n={n}")
        
        return '\n'.join(lines)
    
    def _format_dict_as_text(self, data: Dict, indent: int = 0) -> str:
        """Recursively format dictionary as readable text."""
        lines = []
        prefix = "  " * indent
        
        for key, value in data.items():
            if isinstance(value, dict):
                lines.append(f"{prefix}{key}:")
                lines.append(self._format_dict_as_text(value, indent + 1))
            elif isinstance(value, list):
                lines.append(f"{prefix}{key}: {len(value)} items")
            else:
                lines.append(f"{prefix}{key}: {value}")
        
        return '\n'.join(lines)


class MultiFormatGenerator:
    """Orchestrator for generating multiple visualization formats."""
    
    def __init__(self):
        self.html_generator = PlotlyHTMLGenerator()
        self.artifact_generator = ArtifactGenerator()
        self.config_generator = ConfigGenerator()
        self.text_generator = TextFallbackGenerator()
        self.logger = logging.getLogger(__name__)
    
    def generate_all_formats(self, chart_data: ChartData, 
                           analysis_results: Optional[Dict] = None,
                           formats: Optional[List[VisualizationFormat]] = None) -> Dict[VisualizationFormat, FormatContent]:
        """Generate all requested visualization formats.
        
        Args:
            chart_data: Structured chart information
            analysis_results: Statistical analysis results
            formats: List of formats to generate (None = all formats)
            
        Returns:
            Dictionary mapping format types to format content
        """
        if formats is None:
            formats = list(VisualizationFormat)
        
        generated_formats = {}
        
        for format_type in formats:
            try:
                if format_type == VisualizationFormat.HTML_PLOTLY:
                    content = self.html_generator.generate(chart_data)
                    generated_formats[format_type] = content
                
                elif format_type == VisualizationFormat.ARTIFACT_REACT:
                    content = self.artifact_generator.generate(chart_data, artifact_type="react")
                    generated_formats[format_type] = content
                
                elif format_type == VisualizationFormat.ARTIFACT_HTML:
                    content = self.artifact_generator.generate(chart_data, artifact_type="html")
                    generated_formats[format_type] = content
                
                elif format_type == VisualizationFormat.CHART_CONFIG:
                    content = self.config_generator.generate(chart_data)
                    generated_formats[format_type] = content
                
                elif format_type == VisualizationFormat.TEXT_FALLBACK:
                    content = self.text_generator.generate(chart_data, analysis_results)
                    generated_formats[format_type] = content
                
                self.logger.debug(f"Generated {format_type.value} format successfully")
                
            except Exception as e:
                self.logger.error(f"Failed to generate {format_type.value} format: {e}")
                continue
        
        self.logger.info(f"Generated {len(generated_formats)}/{len(formats)} formats successfully")
        return generated_formats